import {
    Document,
    Packer,
    Paragraph,
    TextRun,
    HeadingLevel,
    Table,
    TableRow,
    TableCell,
    WidthType,
    BorderStyle,
    AlignmentType,
    Header,
    Footer,
    PageNumber,
    NumberFormat
} from "docx";
import { saveAs } from "file-saver";
import { Project, UserStory } from "../../types";

export const generateWordReport = async (project: Project) => {
    const sprint = project.phases.sprint;
    const stories = project.phases.backlog?.epics.flatMap((e) => e.stories) || [];
    const activeStories = stories.filter((s) => s.isInSprint);
    const completedStories = activeStories.filter(
        (s) => s.status.toLowerCase() === "done"
    );
    const totalSP = activeStories.reduce((acc, s) => acc + s.storyPoints, 0);
    const doneSP = completedStories.reduce((acc, s) => acc + s.storyPoints, 0);

    // --- STYLES ---
    const titleStyle = {
        font: "Calibri",
        size: 52, // 26pt
        bold: true,
        color: "2E74B5",
    };
    const header1Style = {
        font: "Calibri",
        size: 32, // 16pt
        bold: true,
        color: "1F4D78",
        spaceBefore: 240,
        spaceAfter: 120,
    };
    const header2Style = {
        font: "Calibri",
        size: 28, // 14pt
        bold: true,
        color: "2E74B5",
        spaceBefore: 200,
        spaceAfter: 100,
    };
    const normalStyle = {
        font: "Calibri",
        size: 22, // 11pt
    };

    // --- SECTIONS ---

    // 1. Cover Page
    const coverPage = [
        new Paragraph({
            text: project.name.toUpperCase(),
            heading: HeadingLevel.TITLE,
            alignment: AlignmentType.CENTER,
            spacing: { before: 5000, after: 400 },
        }),
        new Paragraph({
            text: "Project Status Report",
            heading: HeadingLevel.HEADING_2,
            alignment: AlignmentType.CENTER,
            spacing: { after: 200 },
        }),
        new Paragraph({
            text: `Date: ${new Date().toLocaleDateString()}`,
            alignment: AlignmentType.CENTER,
            spacing: { after: 400 },
        }),
        new Paragraph({
            text: `Generated by SCRUM.AI`,
            alignment: AlignmentType.CENTER,
            run: {
                italics: true,
                color: "666666",
                size: 20
            }
        }),
    ];

    // 2. Vision & Strategy
    const visionSection = [
        new Paragraph({
            text: "1. Vision & Strategy",
            heading: HeadingLevel.HEADING_1,
        }),
        createKeyValue("Vision", project.phases.vision?.text || "Not defined"),
        createKeyValue("Objectives", project.phases.objectives?.text || "Not defined"),
        new Paragraph({ text: "Key Performance Indicators (KPIs):", heading: HeadingLevel.HEADING_2 }),
        createTable([
            ["Metric", "Value", "Target"],
            ...(project.phases.kpis?.table?.map((kpi: any) => [
                kpi.metric || "-",
                kpi.current || "-",
                kpi.target || "-"
            ]) || [["No KPIs defined", "-", "-"]])
        ])
    ];

    // 3. Team
    const teamSection = [
        new Paragraph({
            text: "2. Team & Health",
            heading: HeadingLevel.HEADING_1,
            pageBreakBefore: true,
        }),
        new Paragraph({ text: "Team Roster:", heading: HeadingLevel.HEADING_2 }),
        createTable([
            ["Name", "Role", "Availability"],
            ...(project.phases.team?.members.map(m => [
                m.name,
                m.role,
                `${m.availability}%`
            ]) || [["No members", "-", "-"]])
        ]),
        new Paragraph({ text: "", spacing: { after: 200 } }), // Spacer
    ];

    // 3. Product Hierarchy (Vision -> Epic -> Feature -> Story)
    const hierarchySection: (Paragraph | Table)[] = [
        new Paragraph({
            text: "2. Product Hierarchy",
            heading: HeadingLevel.HEADING_1,
            pageBreakBefore: true,
        }),
    ];

    const epics = project.phases.backlog?.epics || [];
    epics.forEach((epic) => {
        // Level 1: EPIC
        hierarchySection.push(
            new Paragraph({
                text: `Epic: ${epic.title} (Priority: ${epic.priority})`,
                heading: HeadingLevel.HEADING_2,
                spacing: { before: 240, after: 120 },
            })
        );
        hierarchySection.push(
            new Paragraph({
                children: [new TextRun({ text: epic.description || "No description" })],
                style: "Normal",
                spacing: { after: 120 },
            })
        );

        // Features (Level 2)
        const features = epic.features || [];

        if (features.length > 0) {
            features.forEach(feature => {
                hierarchySection.push(
                    new Paragraph({
                        text: `Feature: ${feature.title}`,
                        heading: HeadingLevel.HEADING_3,
                        indent: { left: 360 }, // Indent
                        spacing: { before: 120, after: 60 }
                    })
                );
                // Feature Stories
                if (feature.stories && feature.stories.length > 0) {
                    hierarchySection.push(createStoriesTable(feature.stories));
                } else {
                    hierarchySection.push(new Paragraph({
                        children: [new TextRun({ text: "No stories in this feature.", italics: true })],
                        indent: { left: 720 }
                    }));
                }
            });
        }

        // Direct Stories
        if (features.length === 0 && epic.stories.length > 0) {
            hierarchySection.push(createStoriesTable(epic.stories));
        } else if (features.length === 0 && epic.stories.length === 0) {
            hierarchySection.push(new Paragraph({
                children: [new TextRun({ text: "No stories or features defined.", italics: true })],
                indent: { left: 360 }
            }));
        }
    });

    // 4. Execution & Metrics
    const metricsSection: (Paragraph | Table)[] = [
        new Paragraph({
            text: "3. Execution & Metrics Board",
            heading: HeadingLevel.HEADING_1,
            pageBreakBefore: true,
        }),
        createKeyValue("Current Sprint Status", sprint?.isActive ? "Active" : "Planning/Completed"),
        createKeyValue("Sprint Goal", sprint?.goal || "No Goal Set"),
        // Metrics Table
        new Paragraph({ text: "Key Metrics", heading: HeadingLevel.HEADING_2 }),
        createTable([
            ["Metric", "Value"],
            ["Lead Time (Avg)", `${project.phases.sprint?.leadTime || 0} days`],
            ["Throughput", `${project.phases.sprint?.throughput || 0} items/sprint`],
            ["Velocity", `${project.phases.sprint?.velocity || 0} SP`],
            ["Burndown Status", isBurndownOnTrack(project) ? "On Track" : "Action Required"]
        ])
    ];

    // Helper for Burndown Check (simple logic)
    function isBurndownOnTrack(p: Project) {
        const h = p.phases.sprint?.burndownHistory;
        if (!h || h.length < 2) return true;
        const last = h[h.length - 1];
        return last.remainingHours <= last.idealHours * 1.1; // 10% buffer
    }

    function createStoriesTable(stories: UserStory[]) {
        // Flatten rows to include logs
        const rows: TableRow[] = [
            new TableRow({
                children: ["ID", "Story", "Status", "Est (hr)", "Assigned"].map(h => new TableCell({
                    children: [new Paragraph({ children: [new TextRun({ text: h, bold: true })] })],
                    shading: { fill: "F0F0F0" }
                }))
            })
        ];

        stories.forEach(s => {
            // Main Story Row
            const assignedNames = (s.assignedTo || s.assigneeIds || [])
                .map(id => project.phases.team?.members.find(m => m.id === id)?.name || "Unknown")
                .join(", ");

            rows.push(new TableRow({
                children: [
                    new TableCell({ children: [new Paragraph(s.id)] }),
                    new TableCell({ children: [new Paragraph(s.title)] }),
                    new TableCell({ children: [new Paragraph(s.status)] }),
                    new TableCell({ children: [new Paragraph(s.estimatedHours.toString())] }),
                    new TableCell({ children: [new Paragraph(assignedNames || "-")] }),
                ]
            }));

            // Time Logs Sub-row (if any)
            if (s.timeLogs && s.timeLogs.length > 0) {
                const logText = s.timeLogs.map(l => {
                    const memberName = project.phases.team?.members.find(m => m.id === l.memberId)?.name || "Unknown";
                    return `${new Date(l.date).toLocaleDateString()}: -${l.hours}h (${memberName})`;
                }).join("\n");

                rows.push(new TableRow({
                    children: [
                        new TableCell({
                            children: [
                                new Paragraph({
                                    children: [new TextRun({ text: "Work Logs:", bold: true, size: 20 })]
                                }),
                                new Paragraph({
                                    children: [new TextRun({ text: logText, size: 18, color: "666666" })]
                                })
                            ],
                            columnSpan: 5,
                            shading: { fill: "FAFAFA" }
                        })
                    ]
                }));
            }

            // Tasks Sub-row (if any)
            if (s.tasks && s.tasks.length > 0) {
                const taskText = s.tasks.map(t => `• [${t.status}] ${t.description} (${t.hoursRemaining}h)`).join("\n");
                rows.push(new TableRow({
                    children: [
                        new TableCell({
                            children: [
                                new Paragraph({
                                    children: [new TextRun({ text: "Tasks:", bold: true, size: 20 })]
                                }),
                                new Paragraph({
                                    children: [new TextRun({ text: taskText, size: 18, color: "666666" })]
                                })
                            ],
                            columnSpan: 5,
                            shading: { fill: "FFFFF0" } // Slightly different shade for tasks
                        })
                    ]
                }));
            }
        });

        return new Table({
            width: { size: 100, type: WidthType.PERCENTAGE },
            indent: { size: 720, type: WidthType.DXA },
            rows: rows
        });
    }

    // 5. Agile Retrospective & Impediments (NEW)
    const retroSection = [
        new Paragraph({
            text: "4. Retrospective & Impediments",
            heading: HeadingLevel.HEADING_1,
            pageBreakBefore: true,
        }),
        new Paragraph({ text: "Impediments Encountered", heading: HeadingLevel.HEADING_2 }),
        createTable([
            ["Impediment Type", "Status"],
            ...(project.phases.sprint?.activeManualImpediments?.map(id => {
                const label = ["Mancanza Stakeholder", "Debito Tecnico", "Requisiti Ambigui", "Sovraccarico", "Problemi Ambiente", "Skill Gap"].find(l => {
                    // Quick Map based on checking ID logic or hardcoding map. 
                    // Better to hardcode map here for report consistency or export constant.
                    if (id.includes('stakeholder')) return "Mancanza Stakeholder";
                    if (id.includes('tech-debt')) return "Debito Tecnico";
                    if (id.includes('wip')) return "Sovraccarico";
                    return id;
                }) || id;
                return [label, "Reported"];
            }) || [["No impediments reported", "-"]])
        ]),

        new Paragraph({ text: "Retrospective Summary", heading: HeadingLevel.HEADING_2, spacing: { before: 200 } }),

        // Good
        new Paragraph({ text: "What went well?", heading: HeadingLevel.HEADING_3 }),
        ...(project.phases.sprint?.retrospective?.good?.map(t => new Paragraph({ text: `• ${t}`, spacing: { after: 60 } })) || [new Paragraph({ text: "Nothing recorded", italics: true })]),

        // Bad
        new Paragraph({ text: "What didn't go well?", heading: HeadingLevel.HEADING_3, spacing: { before: 120 } }),
        ...(project.phases.sprint?.retrospective?.bad?.map(t => new Paragraph({ text: `• ${t}`, spacing: { after: 60 } })) || [new Paragraph({ text: "Nothing recorded", italics: true })]),

        // Actions
        new Paragraph({ text: "Action Items (Improvements)", heading: HeadingLevel.HEADING_3, spacing: { before: 120 } }),
        ...(project.phases.sprint?.retrospective?.actions?.map(t => new Paragraph({ text: `• ${t} (Owner: Team)`, spacing: { after: 60 }, bold: true })) || [new Paragraph({ text: "No actions defined", italics: true })]),
    ];

    // 6. Risks (Obeya) - Renumbered to 5 if needed, but let's keep as 5/6
    const risksSection = [
        new Paragraph({
            text: "5. Strategic Risks",
            heading: HeadingLevel.HEADING_1,
            pageBreakBefore: true,
        }),
        createTable([
            ["Risk Description", "Impact", "Mitigation"],
            ...(project.phases.obeya?.risks.map(r => [
                r.risk,
                r.impact,
                r.mitigation
            ]) || [["No critical risks identified", "-", "-"]])
        ])
    ];

    // --- DOCUMENT ASSEMBLY ---
    const doc = new Document({
        sections: [
            {
                properties: {},
                headers: {
                    default: new Header({
                        children: [
                            new Paragraph({
                                children: [
                                    new TextRun({
                                        text: project.name,
                                        bold: true,
                                    }),
                                    new TextRun({
                                        text: "\t\tconfidential",
                                        italics: true,
                                    })
                                ],
                            }),
                        ],
                    }),
                },
                footers: {
                    default: new Footer({
                        children: [
                            new Paragraph({
                                alignment: AlignmentType.CENTER,
                                children: [
                                    new TextRun({ children: ["Page ", PageNumber.CURRENT] }),
                                    new TextRun({ children: [" of ", PageNumber.TOTAL_PAGES] }),
                                ],
                            }),
                        ],
                    }),
                },
                children: [
                    ...coverPage,
                    ...visionSection,
                    ...teamSection,
                    ...hierarchySection,
                    ...metricsSection,
                    ...retroSection,
                    ...risksSection
                ],
            },
        ],
    });

    // Generate and Download
    const buffer = await Packer.toBlob(doc);
    saveAs(buffer, `Project_Report_${project.name.replace(/\s+/g, "_")}_${new Date().toISOString().split('T')[0]}.docx`);
};

// --- HELPERS ---

function createKeyValue(key: string, value: string) {
    return new Paragraph({
        children: [
            new TextRun({ text: `${key}: `, bold: true }),
            new TextRun({ text: value }),
        ],
        spacing: { after: 120 },
    });
}

function createTable(rows: string[][]) {
    return new Table({
        width: {
            size: 100,
            type: WidthType.PERCENTAGE,
        },
        rows: rows.map((row, i) =>
            new TableRow({
                children: row.map(cellText =>
                    new TableCell({
                        children: [new Paragraph({
                            children: [new TextRun({ text: cellText, bold: i === 0 })], // Bold header
                        })],
                        shading: i === 0 ? { fill: "E0E0E0" } : undefined,
                        margins: { top: 100, bottom: 100, left: 100, right: 100 },
                        borders: {
                            top: { style: BorderStyle.SINGLE, size: 1 },
                            bottom: { style: BorderStyle.SINGLE, size: 1 },
                            left: { style: BorderStyle.SINGLE, size: 1 },
                            right: { style: BorderStyle.SINGLE, size: 1 },
                        }
                    })
                )
            })
        )
    });
}
